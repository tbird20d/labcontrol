#!/usr/bin/python3
# SPDX-License-Identifier:  MIT
# vim: set ts=4 sw=4 et :
#
# lc - 'lab control' - a tool for interacting with the LabControl server
#  and for accessing lab information and controlling lab resources,
#  for test programs
#
# Some material, and lots of style, copied from ftc
#
# Copyright 2020-2021 Sony Corporation
# Author: Tim Bird  <tim.bird (at) sony.com>
#
# To Do:
#  - add support for "live" run command
#
# Deferred:
#
#  - add setenv, and use for board-based commands, if the board is missing
#    - maybe can use 'lc config default_board bbb' to get same effect?
#
# see lc.legacy for some code that could be re-used for future features
#

import os
import sys
import re
import tempfile
import importlib

# avoid UnicodeEncodeError exceptions by switching my default encoding
if sys.version_info[0] < 3:
    importlib.reload(sys)
    sys.setdefaultencoding('utf8')

import requests

# python 2to3 added the following urllib imports
# It's not clear that urllib.request or urllib.error are needed
# They are not used anywhere.  Comment them out for now.
#import urllib.request, urllib.parse, urllib.error
import urllib.parse

try:
    import simplejson as json
except ImportError:
    import json

# handle version 2 or 3 of python
if sys.version_info[0] == 2:
    get_input = raw_input
else:
    get_input = input

try:
    from subprocess import getstatusoutput
except:
    from commands import getstatusoutput
    using_commands_gso = True

# MAJOR, MINOR, REVISION, extra_revision
# extra_revision, if non-empty, should start with a dash
# (e.g. "-next", "-rc1")
VERSION = (0, 6, 1, "")

# this is from the REST API standard
RSLT_OK = "success"

# define these as globals
log = None
tail_fd = None
quiet = False
verbose = False
debug = False

# local config file is hidden (starts with a dot), and
# is in the user home directory
config_filename = ".lc.conf"
system_config_filepath = "/etc/lc.conf"

# command_help is a python map with:
#   key=name, value=(summary, long description)
#
command_help = {
"config": ("Show Lab Control configuration setting.",
    """Usage: lc config <name>
  Shows the value for the indicated configuration option

  If no name is specified, shows all configuration items.
"""),

"login": ("Login to a LabControl server.",
    """Usage: lc login
  Authenticate to a LabControl server, and get a token used for future
  requests.

  This command also allows you to set the initial configuration for the
  server URL, if desired.

  You will be prompted for the server, user name and password to use.
  You can press <Enter> to use already-configured values.
"""),

"list": ("Show a list of objects registered with LabControl.",
    """Usage: lc list <obj-type> [-q]
  Prints a list of objects with the indicated object type.

  Options:
    -q         Use "quiet" mode.  This prints only the board names, with no
               additional information. This is suitable for piping to other
               commands.
    <obj-type> Specify the type of objects to list
               (must be one of: boards, devices, or resources)

  Example: lc list boards
"""),

"reserve": ("Reserve a board for use.",
    """Usage: lc {board} reserve [-f] [{duration}]

  Reserve a board for my use.  This assigns a board
  for use with my user account, so that my account has
  exclusive access for testing and manipulating the board.

  If a duration is specified, try to make the reservation for
  that amount of time.  Time is specified using as a string with an 'h'
  or 'm' suffix indicating the number of hours and minutes.  For example:
   '30m' = 30 minutes, '2h' = 2 hours, '1h15m' = 1 hour and 15 minutes.

  If no duration is specified, the reservation may be infinite (lasting
  until manually released) or have a set time, depending on server
  policy.

  If -f is specified, then the reservation is 'forced' and any
  current reservation by another user is released, before the board
  is reserved for this user.

  A message and the exit code indicate whether the resource is
  already reserved.

  ex: lc beablebone reserve 2h"""),

"allocate": ("Reserve a board for my use.",
    """Usage: lc {board} allocate [-f] [{duration}]
  Reserve a board for my use.

  This is the same as the 'reserve' command, and is included
  for compatibility with 'ebf'.
"""),

"release": ("Release a board reservation.",
    """Usage: lc {board} release [force]
  Release a board that was reserved for my use.

  Options:
    force      Release a board that was reserved by another user.
               By default, the 'release' command will only release
               a board that the current user has reserved.  This
               option is used to force the release of a reservation
               by another user.
"""),

"mydevices": ("Show boards that are assigned to me.",
    """Usage: lc mydevices
  Show boards that are reserved my use.  This shows a list of boards
  that were previously allocated or reserved for me.  These are boards
  that are available for my use and testing.
"""),

"power": ("Perform a power operation on a board.",
    """Usage: lc {board} power {operation}
  Perform a power operation on a board.

  Operations:
    status     Show the power status of a board.  The power status
               will be one of "ON", "OFF", or "UNKNOWN", if the
               configured power controller for the device is incapable
               of reporting the power status.
    on         Turn power on to the board.
    off        Turn power off to the board.
    reboot     Reboot the board.

ex: lc myboard power reboot

The labcontrol server will reboot the board.  If the board cannot be rebooted
a message will be provided.
"""),

"get-resource": ("Get a resource associated with a board.",
    """Usage: lc {board} get-resource {resource_type} [{feature-str}]
  Get a resource associated with a board.  The resource type can
  be one of: "power-measurement","serial","camera".

  The resource can then be to perform an action related to the board.

  The output from 'lc' is the name of the requested resource, or if
  no resource is assigned, a string starting with the word "Error:"
  Also, on an error, the return code from 'lc' is non-zero.

ex: pm_resource=$(lc bbb get-resource power-measurement)
    if [ "$?" == 0 ] ; then
       echo "The power management resource for board bbb is '$pm_resource'"
    else:
       echo "$pm_resource"
"""),

"set-config": ("Set configuration for a resource",
    """Usage: lc <resource> set-config <resource_type> [<endpoint_id]
  This command reads standard input to set the configuration of
  a lab resource.  The input data is in json format, and the allowed
  attributes are specific to the resource type.

ex: echo "{ \\"baud_rate\\": \\"115200\\" }" | lc serial-u5 set-config serial
    if [ "$?" == 0 ] ; then
       echo "baud rate was set successfully"
    fi
"""),

"power-measurement": ("Perform a power measurement operation using a resource.",
    """Usage: lc <resource> power-measurement {operation}
  Perform a power measurement operation on a board.
  Note that you can also use the alias 'pm' instead of 'power-measurement'

  Operations:
    start            Start capturing power measurement data, using the
                     indicated resource.  lc will output a string which
                     is a token that can be used to control this instance
                     of power-measurement (that is, to stop, get or delete
                     the power-measurement data).
    stop <token>     Stop capturing power measurement data.
    get-data <token> Return the captured power measurement data.
    delete <token>   Delete the captured power measurement data, on the server.

ex: token=$(lc acme1 power-measurement start)
    lc acme pm stop $token
    lc acme pm get-data $token >power-log.txt
    lc acme pm delete $token
"""),

"serial": ("Perform a serial operation using a resource.",
    """Usage: lc <resource> serial {operation}
  Perform a serial operation on a board.

  Operations:
    start            Start capturing serial data, using the
                     indicated resource.  lc will output a string which
                     is a token that can be used to control this instance
                     of serial capture (that is, to stop, get or delete
                     the serial data).
    stop <token>     Stop capturing serial data.
    get-data <token> Return the captured serial data.
    delete <token>   Delete the captured serial  data, on the server.
    put-data         Put data to the serial resource.  Data is read from
                     standard input.

ex: token=$(lc uart10 serial start)
    lc uart10 serial stop $token
    lc uart10 serial get-data $token >power-log.txt
    lc uart10 serial delete $token
    cat testfile | lc uart10 serial put-data
"""),

"camera": ("Perform a camera operation using a resource.",
    """Usage: lc <resource> camera {operation}
  Perform a camera operation on a board.

  Operations:
    capture          Capture a still image, using the indicated resource.
                     lc outputs the URL reference to the image file.
    start [{secs}]   Start capturing (recording) video, using the indicated
                     resource.  lc will output a string which is a token
                     that can be used to control this instance of video
                     recording (that is, to stop, get or delete
                     the video recording).
    stop <token>     Stop the video recording.
    get-ref <token>  Return a URL reference to the video recording.
    delete <token>   Delete the video recording on the server.

ex1: url=$(lc logitech camera capture)
     curl $url -o image_filename

ex2: token=$(lc logitech camera start 10)
     url=$(lc logitech camera get-ref $token)
     curl $url -o my_video_recording
     lc logitech camera delete $token
"""),

"run": ("Run a command on a board",
    """Usage: lc {board} run {command} {args}...
  Run a command on a board. Output from the command is displayed.

  The return code of the command is the exit code of lc.
"""),

"upload": ("Upload a file or directory to a board",
    """Usage: lc {board} upload {src_path} {dest_path} [{permissions}]
  Upload a file or directory to the indicated file or directory on
  the board.  Permissions can be optionally specified (in UNIX
  numeric octal format).  If the permissions are not specified, then
  the ones currently on the file are used.

  The return code indicates success or failure of the upload.
"""),

"download": ("Download a file or directory from a board (unstable)",
    """Usage: lc {board} download {src_path} {dest_path}
  Download a file or directory from the board to the indicated destination
  path in the local filesystem.

  The return code indicates success or failure of the upload.

  This feature is not complete, and it is in "unstable" status.
"""),

"help": ("Show this online help.",
    """Usage: lc help [<command>]
  If a command is specified, show the usage information for that command."""),

"version": ("Show version information and exit.", ""),

"status": ("Show status of a board.",
        """Usage: lc {board} status

Show the reservation status for a board."""),

}

# here's a helper routine to print a variable with it's name and value
def dvar(name):
    print("DEBUG: python var %s=%s" % (name, caller.f_locals[name]))

# define the debug/verbosity-level based output routines
# Note that not every print should use these.
#  if a print statement is fundamentally part of the execution
#  of a command (e.g. the actual data from a command), it should
#  continue to use 'print()', rather than these level-based
#  functions.
def dprint(msg):
    global debug
    if debug:
        print("DEBUG: " + msg)

def vprint(msg):
    global verbose
    if verbose:
        print(msg)


class config_class:
    def __init__(self, config_filepath):
        # read configuration data from a file
        try:
            data = open(config_filepath, "r").read()
        except:
            error_out("ERROR: could not read LabControl configuration data from %s" % config_filepath)

        conf_map = self.parse_conf(data)

        # set values from conf_map
        self.host = conf_map.get("host", "localhost")
        self.user = conf_map.get("user", "lc_user")
        self.auth_token = conf_map.get("token", "abcd01234")
        self.server = conf_map.get("server", "http://localhost:8000/lcserver.py")
        self.default_board = conf_map.get("default_board", "")
        self.API_URL_BASE = "%s/" % self.server
        self.config_filepath = config_filepath

    # fuego configuration file syntax:
    # ------------------------
    # empty lines and lines starting with # are ignored
    # single-line attribute:
    # name=value
    # multi-line attribute:
    # name="""value line 1
    # line 2, etc."""

    # returns a map with key/value pairs for each item.
    def parse_conf(self, data):
        attr_map = {}
        lines = data.split('\n')
        line_no = 0
        in_block = 0
        block = ""
        for line in lines:
            line_no += 1
            if in_block:
                # try to find end of block
                if line.rstrip().endswith('"""'):
                    # remove quotes and end block
                    line = line.rstrip()
                    block += line[:-3]
                    attr_map[attr] = block
                    in_block = 0
                    continue
                else:
                    block += line + '\n'
                    continue

            # ignore comments
            if line.startswith("#"):
                continue

            # ignore empty lines
            line = line.strip()
            if not line:
                continue

            # if we're outside a block, look for name=value lines

            # line should have an equals in it
            # (either single line name=value, or multi-line block start)
            if line.find("=") == -1:
                print("ERROR: Missing '=' at line %d in Fuego config file" % line_no)
                continue

            (attr, value) = line.split('=', 1)
            attr = attr.strip()
            value = value.strip()
            if value.find('"""') == -1:
                # if a single-line, just record the attribute
                if value.startswith('"') and value.endswith('"'):
                    # remove single-quotes
                    # (if value needs quotes, enclose in triple-quotes)
                    value = value[1:-1]
                attr_map[attr] = value
            else:
                # if the start of a multi-line block...
                vstart = value.find('"""')
                block = value[vstart+3:] + '\n'
                in_block = 1
                # sanity check for block terminator on same line
                # if this line has triple-quotes, then the
                # block begins and ends on the same line.
                if block.endswith('"""\n'):
                    block = block[:block.index('"""')]
                    attr_map[attr] = block
                    in_block = 0
                # NOTE: there's a weird corner case with a line like:
                # 'my_attr=""" foo bar """ more stuff '
                # this will not terminate the block

        # check for dangling material
        if in_block:
            print('ERROR: Syntax error in configuration file.')
            print('Missing """ at end of multiline value for item "%s", at end of file' % attr)
            attr_map[attr] = block

        return attr_map

    def save(self):
        # note: This overwrites any comments in the file
        # It would be nicer to scan the file and replace lines as they appear
        # and to save other config items found in config_class
        # (excepting generated ones)
        fd = open(self.config_filepath, "w+")
        fd.write("server=%s\n" % self.server)
        fd.write("host=%s\n" % self.host)
        fd.write("user=%s\n" % self.user)
        fd.write("token=%s\n" % self.auth_token)
        if self.default_board:
            fd.write("default_board=%s\n" % self.default_board)
        fd.close()


def usage(rcode, options=[]):
    command = ""
    if len(options):
        command = options[0]

    # check if command is legal
    if command and command not in command_help.keys():
        print("Unknown command: %s" % command)
        command = ""
        # drop through to showing list of commands

    if not command:
        # show list of commands
        print("""Usage: lc [global_options] command [options]

Here are the available global options:
 -h, --help     Show this usage help
 -v             Be verbose
 -q             Be quiet
 -c <conf_file> Use specified configuration file
 --debug        Show debugging information

command is one of:
""")
        command_list = list(command_help.keys())
        command_list.sort()
        for command in command_list:
            print("  %13s %s" % (command, command_help[command][0]))
    else:
        # print help for individual command
        print("lc %s: %s" % (command, command_help[command][0]))
        if command_help[command][1]:
            print()
            print(command_help[command][1])

    sys.exit(rcode)

def print_error(message):
    sys.stderr.write("Error: "+message+"\n")
    sys.stderr.flush()


def error_out(message, rcode=1):
    print_error(message)
    sys.exit(rcode)


def dequote(str):
    if str.startswith('"') and str.endswith('"'):
        return str[1:-1]
    else:
        return str

# shows a list title, if not quiet, and
# returns an indent to use for the list
def show_list_title(title):
    global quiet

    if not quiet:
        print(title)
        indent = "   "
    else:
        # machine-readable (-q) output omits the title and indent
        indent = ""
    return indent


# returns a list of objects
# if an error occurs, then the routine errors out with a message
def get_objects_via_api(conf, obj_type, options):
    url = conf.API_URL_BASE+"api/v0.2/" + obj_type

    headers = { "Authorization": "token " + conf.auth_token }

    resp = requests.get(url, headers=headers)
    if resp.status_code != 200:
        error_out("Cannot read %s from server" % obj_type)

    resp_data = resp.json()
    try:
        result = resp_data["result"]
    except:
        error_out("Malformed response from server. Missing 'result'. resp=" + resp_data)

    if result != RSLT_OK:
        # print error
        try:
            reason = resp_data["message"]
        except:
            reason = "for unknown reasons"
        reason = "%s" % reason
        error_out("Could not do operation '%s %s'. From server:\n %s" % (res_type, operation, reason))

    list_data = resp_data["data"]
    if type(list_data) != type([]):
        # print error
        try:
            reason = resp_data["message"]
        except:
            reason = "for unknown reasons"
        error_out("Could not get %s from server: %s" % (obj_type, reason))

    return list_data


def list_objects_via_api(conf, obj_type, options):
    global quiet

    server_obj_type = obj_type
    if obj_type == "boards":
        server_obj_type = "devices"

    obj_list = get_objects_via_api(conf, server_obj_type, options)

    indent = show_list_title("%s on the LabControl server:" % obj_type.title())
    if obj_list:
        for obj in obj_list:
            print(indent + obj)
    else:
        if options:
            extra_msg = " that match the specified criteria"
        else:
            extra_msg = ""
        if not quiet:
            print("No %s found%s." % (obj_type, extra_msg))

    sys.exit(0)

def do_config(conf, options):
    """
        Show all config options, or a single config option
    """
    try:
        name = options[0]
    except:
        # list configuration options
        conf_item_list = []
        for item in list(conf.__dict__.keys()):
            # filter out computed items
            if item not in ["API_URL_BASE"]:
                conf_item_list.append(item)
        conf_item_list.sort()
        for item in conf_item_list:
            print("%s=%s" % (item, getattr(conf, item)))
        sys.exit(1)

    print(getattr(conf, name, ""))

def do_login(conf, options):
    """
        Login to a server, which consists of providing a user and password, and
        getting the authentication token (used for future requests)
    """
    # for now, support only interactive operations

    print("Currently configured for user '%s' and server '%s'" % (conf.user, conf.server))

    new_server = get_input("Enter Server: [%s] " % conf.server)
    if not new_server:
        new_server = conf.server
    new_user = get_input("Enter User Name: [%s] " % conf.user)
    if not new_user:
        new_user = conf.user

    import getpass
    password = getpass.getpass("Enter Password: ")

    # get token from server
    url = new_server+"/api/v0.2/token"
    headers = { "Content-Type": "application/json" }
    jdata = '{ "username": "%s", "password": "%s" }' % (new_user, password)

    resp = requests.post(url, headers=headers, data=jdata)

    if resp.status_code != 200:
        error_out("Cannot login to server '%s'" % new_server )

    resp_data = resp.json()

    try:
        result = resp_data["result"]
    except:
        error_out("Malformed response from server. Missing 'result'. resp=%s" % resp_data)

    if result != RSLT_OK:
        # print error
        try:
            reason = resp_data["message"]
        except:
            reason = "for unknown reason (response missing reason)"
        error_out("Login failure: " + reason)

    try:
        token = resp_data["data"]["token"]
    except:
        error_out("Malformed response from server. Missing 'token'. resp=%s" % resp_data)

    # save token to configuration file
    conf.server = new_server
    conf.user = new_user
    conf.auth_token = token
    conf.save()

    print("Succesfully logged in as user '%s'" % conf.user)

    sys.exit(0)

def do_list(conf, options):
    """
    Show a list of objects on the server.  object type is a required
    first argument.
    """
    try:
        obj_type = options[0]
        del options[0]
    except:
        error_out("No object type specified for list operation" + \
                "Please specify either 'boards', 'devices', or 'resources'.")

    if obj_type not in ["boards", "devices", "resources"]:
        error_out(("Invalid object type '%s'\n" % obj_type) + \
                "Please specify one of: 'boards', 'devices', or 'resources'.")

    list_objects_via_api(conf, obj_type, options)


def do_list_mydevices(conf, options):
    """
    Show devices (boards) assigned to me (that is, with a reservation by me
    on the server).
    """
    url = conf.API_URL_BASE+"api/v0.2/devices/mine"

    headers = { "Authorization": "token " + conf.auth_token }

    resp = requests.get(url, headers=headers)
    if resp.status_code != 200:
        error_out("Cannot read %s from server" % obj_type)

    resp_data = resp.json()
    try:
        result = resp_data["result"]
    except:
        error_out("Malformed response from server. Missing 'result'. resp=" + resp_data)

    if result != RSLT_OK:
        # print error
        try:
            reason = resp_data["message"]
        except:
            reason = "for unknown reasons"
        reason = "%s" % reason
        error_out("Could not do operation 'mydevices'. From server:\n %s" % (reason))

    list_data = resp_data["data"]
    if type(list_data) != type([]):
        # print error
        try:
            reason = resp_data["message"]
        except:
            reason = "for unknown reasons"
        error_out("Could not get %s from server: %s" % (obj_type, reason))

    indent = show_list_title("Boards reserved for me on the LabControl server:")
    if list_data:
        for board in list_data:
            print(indent + board)
    else:
        if not quiet:
            print("No boards found assigned to me.")

    sys.exit(0)

def do_power(conf, options):
    # board is a required first argument
    try:
        board = options[0]
        del options[0]
    except:
        error_out("No board specified for power operation\n" + \
                "Please specify a board from the list available with 'lc list boards'.")

    # figure out what power operation we're performing
    # should be one of 'status', 'on', 'off', 'reboot'
    try:
        operation = options[0].lower()
        del options[0]
    except:
        error_out("No power operation specified.\n" + \
                "Please specify one of 'status', 'on', 'off', or 'reboot'.")

    if operation not in ["status", "on", "off", "reboot"]:
        error_out("Invalid power operation specified.\n" + \
                "Please specify one of 'status', 'on', 'off', or 'reboot'.")

    url = conf.API_URL_BASE+"api/v0.2/devices/%s/power/%s" % (board, operation)

    headers = { "Authorization": "token " + conf.auth_token }

    resp = requests.get(url, headers=headers)
    if resp.status_code != 200:
        error_out("Cannot perform power %s operation on server" % operation )

    resp_data = resp.json()

    try:
        result = resp_data["result"]
    except:
        error_out("Malformed response from server. Missing 'result'. resp=%s" % resp_data)

    if result != RSLT_OK:
        # print error
        try:
            reason = resp_data["message"]
        except:
            reason = "for unknown reasons"
        error_out("Could not do operation 'power %s'. %s" % (operation, reason))

    # operation was performed, result was "success"

    # report status depending on operation
    if operation in ["on", "off"]:
        print("Device %s is powered %s" % (board, operation.upper()))
        return
    if operation == "reboot":
        print("Device %s was rebooted." % board)
        return
    if operation == "status":
        power_status = resp_data["data"]
        print("Device %s is powered %s" % (board, power_status))
        return

    # this seems unlikely, given the checks above
    # but be thorough in error handling
    error_out("Invalid operation '%s' for power command" % operation)

def do_run(conf, options):
    # board is a required first argument
    try:
        board = options[0]
        del options[0]
    except:
        error_out("No board specified for run operation\n" + \
                "Please specify a board from the list available with 'lc list boards'.")

    if not options:
        error_out("No command was specified to run.")

    run_cmd = " ".join(options)

    run_cmd_escaped = json.dumps(run_cmd)

    url = conf.API_URL_BASE+"api/v0.2/devices/%s/run/" % board

    jdata = '{ "command": %s, "device_ip": "*", "username":"*" }' % run_cmd_escaped

    headers = { "Authorization": "token " + conf.auth_token,
            "Content-type": "application/json"}

    resp = requests.post(url, headers=headers, data=jdata)
    if resp.status_code != 200:
        error_out("Cannot perform 'run' operation on server")

    #print("resp.content='%s'" % resp.content)

    resp_data = resp.json()
    #print("resp_data='%s'" % resp_data)

    try:
        result = resp_data["result"]
    except:
        error_out("Malformed response from server. Missing 'result'. resp=%s" % resp_data)

    if result != RSLT_OK:
        # print error
        try:
            reason = resp_data["message"]
        except:
            reason = "for unknown reasons"
        error_out("Could not do operation 'run %s'. %s" % (operation, reason))

    # command was performed, result was "success"
    return_code = resp_data["data"]["return_code"]
    output = resp_data["data"]["data"]
    for line in output:
        sys.stdout.write(line)
        #sys.stdout.write(line + "\n")

    sys.exit(return_code)

def do_upload(conf, options):
    # board is a required first argument
    try:
        board = options[0]
        del options[0]
    except:
        error_out("No board specified for upload operation\n" + \
                "Please specify a board from the list available with 'lc list boards'.")

    if not options:
        error_out("No file was specified to upload.")

    src_filename = options[0]
    del options[0]

    if not options:
        error_out("Missing destination location on board for upload.")
    dest_path = options[0]
    del options[0]

    permissions = None
    if options:
        permissions = options[0]
        del options[0]

    if options:
        error_out("Too many arguments to upload command.")

    if not os.path.exists(src_filename):
        error_out("Can not find file or directory '%s' to upload." % src_filename)
    if not permissions:
        permissions = oct(os.stat(src_filename).st_mode)[-3:]

    url = conf.API_URL_BASE+"api/v0.2/devices/%s/upload/" % board

    tmpdir = None
    tar_path = None
    data = { "path": dest_path, "device_ip": "10.0.1.1", "username":"root", "permissions": permissions }

    if os.path.isdir(src_filename):
      # if it's a directory, tar it up before sending it
      tmpdir = tempfile.mkdtemp()
      full_path = os.path.realpath(src_filename)
      src_parent = os.path.dirname(full_path)
      src_name = os.path.basename(full_path)
      tar_path = tmpdir + "/" + src_name + ".tar.gz"
      tar_cmd = "tar -czf %s -C %s %s" % (tar_path, src_parent, src_name)
      rcode, output = getstatusoutput(tar_cmd)
      data["extract"] = "true"
      files = { "file": (tar_path, open(tar_path, 'rb')) }
    else:
      files = { "file": (src_filename, open(src_filename, 'rb')) }

    headers = { "Authorization": "token " + conf.auth_token,
            "Content-type": "application/json"}

    resp = requests.post(url, headers=headers, data=data, files=files )
    if resp.status_code != 200:
        print("resp.status_code=%s" % resp.status_code)
        error_out("Cannot perform 'upload' operation on server")

    # remove intermediate files and dirs, if some were created
    if tar_path:
        os.remove(tar_path)
    if tmpdir:
        os.rmdir(tmpdir)

    #print("resp.content='%s'" % resp.content)

    resp_data = resp.json()
    #print("resp_data='%s'" % resp_data)

    try:
        result = resp_data["result"]
    except:
        error_out("Malformed response from server. Missing 'result'. resp=%s" % resp_data)

    if result != RSLT_OK:
        # print error
        try:
            reason = resp_data["message"]
        except:
            reason = "for unknown reasons"
        error_out("Could not do upload: %s" % reason)

    # command was performed, result was "success"
    msg = resp_data["message"]
    print(msg)

    sys.exit(0)

def do_download(conf, options):
    # board is a required first argument
    try:
        board = options[0]
        del options[0]
    except:
        error_out("No board specified for download operation\n" + \
                "Please specify a board from the list available with 'lc list boards'.")

    if not options:
        error_out("No file or directory was specified to download.")

    src_path = options[0]
    del options[0]

    if not options:
        error_out("Missing destination location download.")
    dest_path = options[0]
    del options[0]

    if options:
        error_out("Too many arguments to download command.")

    url = conf.API_URL_BASE+"api/v0.2/devices/%s/download/?compress=true&path=%s&device_ip=*&username=*" % (board, src_path)

    headers = { "Authorization": "token " + conf.auth_token,
            "Content-type": "application/json"}

    resp = requests.get(url, headers=headers)

    if resp.status_code != 200:
        print("resp.status_code=%s" % resp.status_code)
        error_out("Cannot perform 'download' operation on server")

    #try:
    #    result = resp_data["result"]
    #except:
    #    error_out("Malformed response from server. Missing 'result'. resp=%s" % resp_data)
    #
    #if result != RSLT_OK:
    #    # print error
    #    try:
    #        reason = resp_data["message"]
    #    except:
    #        reason = "for unknown reasons"
    #    error_out("Could not do upload: %s" % reason)

    tmpdir = tempfile.mkdtemp()
    src_name = os.path.basename(src_path)
    tar_name = src_name + ".tar.gz"
    tar_path = tmpdir + "/" + tar_name

    data = resp.content
    with open(tar_path, "wb") as fd:
        fd.write(data)

    dest_parent = os.path.dirname(os.path.realpath(dest_path))

    # extract the tar to retrieve the file(s)
    tar_cmd = "tar -C %s -xf %s" % (tmpdir, tar_path)
    rcode, output = getstatusoutput(tar_cmd)
    if rcode:
        error_out("Cannot perform tar for 'download' operation")

    cp_cmd = "cp -rf %s %s" % (tmpdir + src_path, dest_path)
    rcode, output = getstatusoutput(cp_cmd)
    if rcode:
        error_out("Cannot perform cp for 'download' operation")

    # remove intermediate files and dirs, if some were created

    if tmpdir:
        import shutil
        shutil.rmtree(tmpdir)

    #print("resp.content='%s'" % resp.content)
    print('Successfully Downloaded "%s" into "%s"' % (src_name, dest_path))
    sys.exit(0)

# parse duration string in the form of: xxhyym
# returns number of minutes, or
#   0 on parse error
def parse_timestr(ts):
    minutes = 0
    if ('h' not in ts) and ('m' not in ts):
        return 0

    if 'h' in ts:
        hours, rest = ts.split('h', 1)
        if not re.match("^[0-9]+$", hours):
            return 0
        minutes += int(hours) * 60
        ts = rest

    if 'm' in ts:
        mins, rest = ts.split('m', 1)
        if rest:
            # 'm', if present, should be last element of string
            # if something follows 'm', it's an error
            return 0

        if not re.match("^[0-9]+$", mins):
            return 0
        minutes += int(mins)

    if rest:
        return 0

    return minutes

def do_reserve(conf, options, cmd='reserve'):
    # board is a required first argument
    try:
        board = options[0]
        del options[0]
    except:
        error_out("No board specified for %s operation\n" % cmd + \
                "Please specify a board from 'lc list boards'.")

    # could set a default number of minutes here, but that should
    # be server/lab policy
    minutes = None

    if options:
        minutes = parse_timestr(options[0])
        if not minutes:
            error_out("Invalid duration '%s'" % options[0])

    url = conf.API_URL_BASE+"api/v0.2/devices/%s/assign/" % board
    if minutes:
        url += "%s/" % str(minutes)

    headers = { "Authorization": "token " + conf.auth_token }

    resp = requests.get(url, headers=headers)
    if resp.status_code != 200:
        error_out("Cannot perform %s operation on server" % cmd )

    resp_data = resp.json()

    try:
        result = resp_data["result"]
    except:
        error_out("Malformed response from server. Missing 'result'. resp=%s" % resp_data)

    if result != RSLT_OK:
        # print error
        try:
            reason = resp_data["message"]
        except:
            reason = "for unknown reasons"
        error_out("%s" % reason)

    # operation was performed, result was "success"
    print("Device is assigned to user %s" % conf.user)
    return

def do_release(conf, options):
    # board is a required first argument
    try:
        board = options[0]
        del options[0]
    except:
        error_out("No board specified for release operation\n" + \
            "Please specify a board from 'lc list boards'.")

    url = conf.API_URL_BASE+"api/v0.2/devices/%s/release" % board

    if len(options) and options[0]=="force":
        url += "/force"

    headers = { "Authorization": "token " + conf.auth_token }

    resp = requests.get(url, headers=headers)
    if resp.status_code != 200:
        error_out("Cannot perform release operation on server")

    resp_data = resp.json()

    try:
        result = resp_data["result"]
    except:
        error_out("Malformed response from server. Missing 'result'. resp=%s" % resp_data)

    if result != RSLT_OK:
        # print error
        try:
            reason = resp_data["message"]
        except:
            reason = "Could not do 'assign' operation, for unknown reasons"
        error_out("%s" % reason)

    # operation was performed, result was "success"
    print('Device "%s" is released and available to use.' % board)
    return


# show the status of a board
def do_status(conf, options):
    board = options[0]
    del(options[0])

    url = conf.API_URL_BASE+"api/v0.2/devices/" + board

    headers = { "Authorization": "token " + conf.auth_token }

    resp = requests.get(url, headers=headers)
    if resp.status_code != 200:
        error_out("Cannot read %s from server" % obj_type)

    try:
        resp_data = resp.json()
    except:
        error_out("Could not parse data from server")

    try:
        result = resp_data["result"]
    except:
        error_out("Can not determine result from server")

    if result != RSLT_OK:
        try:
            reason = resp_data["message"]
        except:
            reason = "Unknown failure from server"
        error_out(reason)

    print("Status for board: %s" % board)

    # show who is currently using board
    assigned_to = resp_data.get("AssignedTo", "nobody")
    end_time = resp_data.get("end_time", "unknown")
    if end_time != "unknown":
        end_str = ", ending %s" % end_time
    else:
        end_str = ""

    if assigned_to != "nobody":
        print('Board "%s" is assigned to user "%s"%s.' % (board, assigned_to, end_str))
    else:
        print('Board "%s" is not reserved.' % (board))

    # FIXTHIS - do_status could report other board status data, like:
    #   board power-on status
    #   whether board is running linux (pingable?)
    #   future reservations for board


def do_get_resource(conf, options):
    # board is a required first argument
    try:
        board = options[0]
        del options[0]
    except:
        error_out("No board specified for get_resource operation\n" \
                "Please specify a board from 'lc list boards'.")

    try:
        res_type = options[0]
        del options[0]
    except:
        error_out("No resource type specified for get_resource operation\n" \
                "Please specify a valid resource type.")

    api_url = "api/v0.2/devices/%s/get_resource/%s" % (board, res_type)
    url = conf.API_URL_BASE + api_url

    if options:
        # make feature string suitable to append to url
        feature_str = urllib.parse.quote(options[0]).replace("/", "%2F")
        url += "/" +  feature_str.replace("/", "%2F")

    headers = { "Authorization": "token " + conf.auth_token }

    resp = requests.get(url, headers=headers)
    if resp.status_code != 200:
        error_out("Cannot perform 'get_resource' operation on server")

    resp_data = resp.json()

    try:
        result = resp_data["result"]
    except:
        error_out("Malformed response from server. Missing 'result'. resp=%s" % resp_data)

    if result != RSLT_OK:
        # print error
        try:
            reason = resp_data["message"]
            if reason.startswith("Error: "):
                    reason = reason[6:]
        except:
            reason = "for unknown reasons"
        error_out("%s" % reason)

    try:
        data = resp_data["data"]
    except:
        error_out("Malformed response from server. Missing 'data'. resp=%s" % resp_data)

    # operation was performed, result was "success", print the resource name
    print(data)
    return

def do_power_measurement(conf, options, cmd):
    # resource is a required first argument
    try:
        resource = options[0]
        del options[0]
    except:
        error_out("No resource specified for power operation\n" + \
                "Please specify a resource associated with this board\n" + \
                "try 'lc list resources'.")

    # figure out what power operation we're performing
    # should be one of 'start', 'stop', 'get-data', 'delete'
    try:
        operation = options[0].lower()
        del options[0]
    except:
        error_out("No power-measurement operation specified.\n" + \
                "Please specify one of 'start', 'stop', 'get-data', or 'delete'.")

    if operation not in ["start", "stop", "get-data", "delete"]:
        error_out("Invalid power operation specified.\n" + \
                "Please specify one of 'start', 'stop', 'get-data', or 'delete'.")

    url_op  = { "start": "start-capture", "stop": "stop-capture", "get-data": "get-data", "delete": "delete" }[operation]

    url = conf.API_URL_BASE+"api/v0.2/resources/%s/power-measurement/%s" % (resource, url_op)
    headers = { "Authorization": "token " + conf.auth_token }

    if operation in ["stop", "get-data", "delete"]:
        try:
            token = options[0]
            del options[0]
        except:
            error_out("No token provided for '%s' operation.\n" % operation)
        url += "/%s" % token
        # FIXTHIS - power-measurement operation should be a 'post' according to the spec
        resp = requests.get(url, headers=headers)
    else:
        resp = requests.get(url, headers=headers)

    if resp.status_code != 200:
        error_out("Cannot perform power-measurement %s operation on server" % operation )

    resp_data = resp.json()

    try:
        result = resp_data["result"]
    except:
        error_out("Malformed response from server. Missing 'result'. resp=%s" % resp_data)

    if result != RSLT_OK:
        # print error
        try:
            reason = resp_data["message"]
        except:
            reason = "for unknown reasons"
        error_out("Could not do operation 'power-measurement %s'. From server:\n %s" % (operation, reason))

    # operation was performed, result was "success"

    # report status depending on operation
    if operation == "start":
        # output token to user
        try:
            token = resp_data["data"]
        except:
            error_out("Missing data capture token from server.")

        print(token)
        return

    if operation == "stop":
        print("Capture was stopped.")
        return
    if operation == "delete":
        print("Capture was deleted from server.")
        return
    if operation == "get-data":
        # write json capture data to stdout
        try:
            data = resp_data["data"]
        except:
            error_out("Missing captureed from server.")

        print(data)
        return

    # this seems unlikely, given the checks above
    # but be thorough in error handling
    error_out("Invalid operation '%s' for power-measurement command" % operation)

def do_set_config(conf, options, cmd):
    # resource is a required first argument
    try:
        resource = options[0]
        del options[0]
    except:
        error_out("No resource specified for set-config operation\n" + \
                "Please specify a resource associated with this board\n" + \
                "try 'lc list resources'.")

    try:
        res_type = options[0]
        del options[0]
    except:
        error_out("No resource type specified for set-config operation\n" + \
                "Please specify a valid resource type (only 'serial' is supported)\n")

    operation = "set-config"

    url = conf.API_URL_BASE+"api/v0.2/resources/%s/%s/set-config" % (resource, res_type)
    headers = { "Authorization": "token " + conf.auth_token }

    # read standard input for json data
    config_data = sys.stdin.read()

    #print("config data=%s" % config_data)

    resp = requests.post(url, headers=headers, data=config_data)

    if resp.status_code != 200:
        error_out("Cannot perform %s %s operation on server" % (res_type, operation))

    try:
        resp_data = resp.json()
    except ValueError:
        error_out("Could not parse response data as json. data=" + resp.content)

    try:
        result = resp_data["result"]
    except:
        error_out("Malformed response from server. Missing 'result'. resp=" + resp_data)

    if result != RSLT_OK:
        # print error
        try:
            reason = resp_data["message"]
        except:
            reason = "for unknown reasons"
        reason = "%s" % reason
        error_out("Could not do operation '%s %s'. From server:\n %s" % (res_type, operation, reason))

    # operation was performed, result was "success"
    print("Set_config operation was successful")

# this is almost verbatim from do_power_measurement - should try
# to find a way to coalesce these.
def do_serial(conf, options, cmd):
    # resource is a required first argument
    try:
        resource = options[0]
        del options[0]
    except:
        error_out("No resource specified for serial operation\n" + \
                "Please specify a resource associated with this board\n" + \
                "try 'lc list resources'.")

    # figure out what power operation we're performing
    # should be one of 'start', 'stop', 'get-data', 'delete'
    try:
        operation = options[0].lower()
        del options[0]
    except:
        error_out("No serial operation specified.\n" + \
                "Please specify one of 'start', 'stop', 'get-data', or 'delete'.")

    if operation not in ["start", "stop", "get-data", "delete", "put-data"]:
        error_out("Invalid serial specified.\n" + \
                "Please specify one of 'start', 'stop', 'get-data', or 'delete'.")

    url_op  = { "start": "start-capture", "stop": "stop-capture", "get-data": "get-data", "delete": "delete", "put-data": "put-data" }[operation]

    url = conf.API_URL_BASE+"api/v0.2/resources/%s/serial/%s" % (resource, url_op)
    headers = { "Authorization": "token " + conf.auth_token }

    if operation in ["stop", "get-data", "delete"]:
        try:
            token = options[0]
            del options[0]
        except:
            error_out("No token provided for '%s' operation.\n" % operation)
        url += "/%s" % token
        # FIXTHIS - serial operation should be a 'post' according to the spec
        resp = requests.get(url, headers=headers)
    elif operation == "put-data":
        # read data to put, from standard input
        data = sys.stdin.read()
        resp = requests.post(url, headers=headers, data=data)
    else:
        resp = requests.get(url, headers=headers)

    if resp.status_code != 200:
        error_out("Cannot perform serial %s operation on server" % operation )

    resp_data = resp.json()

    try:
        result = resp_data["result"]
    except:
        error_out("Malformed response from server. Missing 'result'. resp=%s" % resp_data)

    if result != RSLT_OK:
        # print error
        try:
            reason = resp_data["message"]
        except:
            reason = "for unknown reasons"
        error_out("Could not do operation 'serial %s'. From server:\n %s" % (operation, reason))

    # operation was performed, result was "success"

    # report status depending on operation
    if operation == "start":
        # output token to user
        try:
            token = resp_data["data"]
        except:
            error_out("Missing data capture token from server.")

        print(token)
        return

    if operation == "stop":
        print("Capture was stopped.")
        return
    if operation == "delete":
        print("Capture was deleted from server.")
        return
    if operation == "get-data":
        # write json capture data to stdout
        try:
            data = resp_data["data"]
        except:
            error_out("Missing captured from server.")

        print(data)
        return
    if operation == "put-data":
        print("Data was put successfully.")
        return

    # this seems unlikely, given the checks above
    # but be thorough in error handling
    error_out("Invalid operation '%s' for serial command" % operation)

# this is almost verbatim from do_serial - should try
# to find a way to coalesce these.
def do_camera(conf, options, cmd):
    # resource is a required first argument
    try:
        resource = options[0]
        del options[0]
    except:
        error_out("No resource specified for camera operation\n" + \
                "Please specify a resource associated with this board\n" + \
                "try 'lc list resources' or 'lc {board} get-resource camera'.")

    # figure out what camera operation we're performing
    # should be one of 'capture', 'start', 'stop', 'get-ref', 'delete'
    try:
        operation = options[0].lower()
        del options[0]
    except:
        error_out("No camera operation specified.\n" + \
                "Please specify one of 'capture', 'start', 'stop', 'get-ref', or 'delete'.")

    if operation not in ["capture", "start", "stop", "get-ref", "delete"]:
        error_out("Invalid camera operation specified.\n" + \
                "Please specify one of 'capture, 'start', 'stop', 'get-ref', or 'delete'.")


    url_op  = operation
    if url_op == "start":
        url_op = "start-capture"
    elif url_op == "stop":
        url_op = "stop-capture"

    url = conf.API_URL_BASE+"api/v0.2/resources/%s/camera/%s" % (resource, url_op)
    headers = { "Authorization": "token " + conf.auth_token }

    if operation in ["stop", "get-ref", "delete"]:
        try:
            token = options[0]
            del options[0]
        except:
            error_out("No token provided for '%s' operation.\n" % operation)
        url += "/%s" % token
        resp = requests.get(url, headers=headers)
    elif operation == "start":
        # get optional duration
        try:
            duration = options[0]
            del options[0]
            url += "/%s" % duration
        except IndexError:
            pass

        resp = requests.post(url, headers=headers)
    else:
        resp = requests.get(url, headers=headers)

    if resp.status_code != 200:
        error_out("Cannot perform camera %s operation on server" % operation )

    resp_data = resp.json()

    try:
        result = resp_data["result"]
    except:
        error_out("Malformed response from server. Missing 'result'. resp=%s" % resp_data)

    if result != RSLT_OK:
        # print error
        try:
            reason = resp_data["message"]
        except:
            reason = "for unknown reasons"
        error_out("Could not do operation 'camera %s'. From server:\n %s" % (operation, reason))

    # operation was performed, result was "success"

    # report status depending on operation
    if operation == "start":
        # output token to user
        try:
            token = resp_data["data"]
        except:
            error_out("Missing data capture token from server.")

        print(token)
        return

    if operation == "delete":
        print("Video recording was deleted from server.")
        return

    if operation == "stop":
        print("Video recording was stopped.")
        return

    if operation in ["get-ref", "capture"]:
        try:
            url_path = resp_data["data"]
        except:
            error_out("Missing URL for captured data from server.")

        print(url_path)
        return

    # this seems unlikely, given the checks above
    # but be thorough in error handling
    error_out("Invalid operation '%s' for camera command" % operation)


def main():
    global verbose
    global quiet
    global debug
    global server

    # find the configuration file

    # check for config in user's home directory
    # if present, this supercedes the system-wide config
    home = os.environ.get("HOME", "")
    config_filepath = home + os.sep + config_filename

    if not home or not os.path.exists(config_filepath):
        config_filepath = system_config_filepath

    if len(sys.argv) < 2:
        error_out('Missing command\nUse "lc help" to get usage help.', 1)

    # parse arguments
    command_list = list(command_help.keys())
    command_list.extend(["--help", "-h", "pm"])
    options = []

    board = ""
    command = ""
    quiet = False
    verbose = False
    # find command, board, and any arguments
    arglist = sys.argv[1:]
    for arg in arglist:
        if arg == "-q":
            quiet = True
            continue
        if arg == "-v":
            verbose = True
            ll_verbose = True
            continue
        if arg == "--debug":
            debug = True
            ll_debug = True
            continue
        if arg == "-c":
            config_filepath = arglist[arglist.index("-c")+1]
            # this is dicey - it relies on the for loop to continue
            # properly if arglist is manipulated while the 'for' is running
            arglist.remove(config_filepath)
            continue
        if arg in command_list:
            # support "lc <command> help"
            if (arg == "help" or arg == "-h" or arg == "--help") and command:
                options.append(command)
                command = arg
                continue

            # support "lc help <command>" and "lc run reboot"
            # -- where arg has same name as a legal lc command
            if command:
                # this is an argument to the command
                # which was already found
                # note: check for 'help' arg (above) must come first
                options.append(arg)
            else:
                # normal "lc <command>" case

                command = arg
            continue

        options.append(arg)

    # if no command recognized, return
    if not command:
        error_out('Missing or unregonized command\nUse "lc help" to get usage help.', 1)

    if command == "help" or command == "--help" or command == "-h":
        usage(0, options)

    if command == "version":
        print("lc: version %d.%d.%d%s" % VERSION)
        sys.exit(0)

    # read config
    conf = config_class(config_filepath)

    if command == "config":
        do_config(conf, options)
        sys.exit(0)
        try:
            name = options[0]
        except:
            # list configuration options
            conf_item_list = []
            for item in list(conf.__dict__.keys()):
                # filter out computed items
                if item not in ["API_URL_BASE"]:
                    conf_item_list.append(item)
            conf_item_list.sort()
            for item in conf_item_list:
                print("%s=%s" % (item, getattr(conf, item)))
            sys.exit(1)

        print(getattr(conf, name, ""))

    if command == "login":
        do_login(conf, options)

    if command == "list":
        do_list(conf, options)

    if command == "power":
        do_power(conf, options)
        sys.exit(0)

    if command in ["allocate", "reserve"]:
        do_reserve(conf, options, command)
        sys.exit(0)

    if command == "release":
        do_release(conf, options)
        sys.exit(0)

    if command == "mydevices":
        do_list_mydevices(conf, options)
        sys.exit(0)

    if command == "status":
        do_status(conf, options)
        sys.exit(0)

    if command == "get-resource":
        do_get_resource(conf, options)
        sys.exit(0)

    if command in ["power-measurement", "pm"]:
        do_power_measurement(conf, options, command)
        sys.exit(0)

    if command == "serial":
        do_serial(conf, options, command)
        sys.exit(0)

    if command == "set-config":
        do_set_config(conf, options, command)
        sys.exit(0)

    if command in ["camera"]:
        do_camera(conf, options, command)
        sys.exit(0)

    if command == "run":
        do_run(conf, options)
        # no return here

    if command == "upload":
        do_upload(conf, options)
        # no return here

    if command == "download":
        do_download(conf, options)
        # no return here

    error_out("Unknown command %s" % command)


if __name__ == "__main__":
    try:
        main()
    except requests.ConnectionError as e:
        error_out("""Could not connect to server: %s.
Check that server is running and that you have the right
server in your configuration file.""" % str(e))
        sys.exit(1)
