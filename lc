#!/usr/bin/python
# SPDX-License-Identifier:  MIT
# vim: set ts=4 sw=4 et :
#
# lc - 'lab control' - a tool for interacting with the LabControl server
#  and for accessing lab information and controlling lab resources,
#  for test programs
#
# Some material, and lots of style, copied from ftc
#
# Copyright 2020-2021 Sony Corporation
# Author: Tim Bird  <tim.bird (at) sony.com>
#
# To Do:
#  - add support for get-endpoint - replaced with get-resource <type> <feature>
#  - add support for set-config
#  - add support for run
#  - add support for upload
#  - add support for download
#  - make lc work with ebf server
#  - make ebf work with lc server
#
# Deferred:
#
#  - add setenv, and use for board-based commands, if the board is missing
#    - maybe can use 'lc config default_board bbb' to get same effect?
#
# see lc.legacy for some code that could be re-used for future features
#

import os
import sys

# avoid UnicodeEncodeError exceptions by switching my default encoding
if sys.version_info[0] < 3:
    reload(sys)
    sys.setdefaultencoding('utf8')

import requests
import urllib
try:
    import simplejson as json
except ImportError:
    import json

# handle version 2 or 3 of python
if sys.version_info[0] == 2:
    get_input = raw_input
else:
    get_input = input



# MAJOR, MINOR, REVISION, extra_revision
# extra_revision, if non-empty, should start with a dash
# (e.g. "-next", "-rc1")
VERSION = (0, 4, 0, "")

# this is from the REST API standard
RSLT_OK = "success"

# define these as globals
log = None
tail_fd = None
quiet = False
verbose = False
debug = False

# local config file is hidden (starts with a dot), and
# is in the user home directory
config_filename = ".lc.conf"
system_config_filepath = "/etc/lc.conf"

# command_help is a python map with:
#   key=name, value=(summary, long description)
#
command_help = {
"config": ("Show Lab Control configuration setting.",
    """Usage: lc config <name>
  Shows the value for the indicated configuration option

  If no name is specified, shows all configuration items.
"""),

"login": ("Login to a LabControl server.",
    """Usage: lc login
  Authenticate to a LabControl server, and get a token used for future
  requests.

  This command also allows you to set the initial configuration for the
  server URL, if desired.

  You will be prompted for the server, user name and password to use.
  You can press <Enter> to use already-configured values.
"""),

"list": ("Show a list of objects registered with LabControl.",
    """Usage: lc list <obj-type> [-q]
  Prints a list of objects with the indicated object type.

  Options:
    -q         Use "quiet" mode.  This prints only the board names, with no
               additional information. This is suitable for piping to other
               commands.
    <obj-type> Specify the type of objects to list
               (must be one of: boards, devices, or resources)

  Example: lc list boards
"""),

"allocate": ("Reserve a board for my use.",
    """Usage: lc {board} allocate
  Reserve a board for my use.  This assigns a board
  for use with my user account, so that my account has
  exclusive access for testing and manipulating the board.

  This is the same as the 'reserve' command, and is included
  for compatibility with 'ebf'.
"""),

"reserve": ("Reserve a board for my use.",
    """Usage: lc {board} reserve
  Reserve a board for my use.  This assigns a board
  for use with my user account, so that my account has
  exclusive access for testing and manipulating the board.

  This is the same as the 'allocate' command.
"""),

"release": ("Release a board reservation.",
    """Usage: lc {board} release
  Release a board that was reserved for my use.

  Options:
    force      Release a board that was reserved by another user.
               By default, the 'release' command will only release
               a board that the current user has reserved.  This
               option is used to force the release of a reservation
               by another user.
"""),

"mydevices": ("Show boards that are assigned to me.",
    """Usage: lc mydevices
  Show boards that are reserved my use.  This shows a list of boards
  that were previously allocated or reserved for me.  These are boards
  that are available for my use and testing.
"""),

"power": ("Perform a power operation on a board.",
    """Usage: lc {board} power {operation}
  Perform a power operation on a board.

  Operations:
    status     Show the power status of a board.  The power status
               will be one of "ON", "OFF", or "UNKNOWN", if the
               configured power controller for the device is incapable
               of reporting the power status.
    on         Turn power on to the board.
    off        Turn power off to the board.
    reboot     Reboot the board.

ex: lc myboard power reboot

The labcontrol server will reboot the board.  If the board cannot be rebooted
a message will be provided.
"""),

"get-resource": ("Get a resource associated with a board.",
    """Usage: lc <board> get-resource <resource_type> [<feature-str>]
  Get a resource associated with a board.  The resource type can
  be one of: "power_measurement" "power_controller".

  The resource can then be to perform an action related to the board.

  The output from 'lc' is the name of the requested resource, or if
  no resource is assigned, a string starting with the word "Error:"
  Also, on an error, the return code from 'lc' is non-zero.

ex: pm_resource=$(lc bbb get-resource power_measurement)
    if [ "$?" == 0 ] ; then
       echo "The power management resource for board bbb is '$pm_resource'"
    else:
       echo "$pm_resource"
"""),

"set-config": ("Set configuration for a resource",
    """Usage: lc <resource> set-config <resource_type> [<endpoint_id]
  This command reads standard input to set the configuration of
  a lab resource.  The input data is in json format, and the allowed
  attributes are specific to the resource type.

ex: echo "{ \\"baud_rate\\": \\"115200\\" }" | lc serial-u5 set-config serial
    if [ "$?" == 0 ] ; then
       echo "baud rate was set successfully"
    fi
"""),

"power-measurement": ("Perform a power measurement operation using a resource.",
    """Usage: lc <resource> power_measurement {operation}
  Perform a power measurement operation on a board.
  Note that you can also use the alias 'pm' instead of 'power-measurement'

  Operations:
    start            Start capturing power measurement data, using the
                     indicated resource.  lc will output a string which
                     is a token that can be used to control this instance
                     of power_measurement (that is, to stop, get or delete
                     the power_measurement data).
    stop <token>     Stop capturing power measurement data.
    get-data <token> Return the captured power measurement data.
    delete <token>   Delete the captured power measurement data, on the server.

ex: token=$(lc acme1 power-measurement start)
    lc acme pm stop $token
    lc acme pm get-data $token >power-log.txt
    lc acme pm delete $token
"""),

"serial": ("Perform a serial operation using a resource.",
    """Usage: lc <resource> serial {operation}
  Perform a serial operation on a board.

  Operations:
    start            Start capturing serial data, using the
                     indicated resource.  lc will output a string which
                     is a token that can be used to control this instance
                     of serial capture (that is, to stop, get or delete
                     the serial data).
    stop <token>     Stop capturing serial data.
    get-data <token> Return the captured serial data.
    delete <token>   Delete the captured serial  data, on the server.

ex: token=$(lc uart10 serial start)
    lc uart10 serial stop $token
    lc uart10 serial get-data $token >power-log.txt
    lc uart10 serial delete $token
"""),

"run": ("run a command on a board",
    """Usage: lc <board> run {command} {args}...
  Run a command on a board. Output from the command is displayed.

  The return code of the command is the exit code of lc.
"""),

"help": ("Show this online help.",
    """Usage: lc help [<command>]
  If a command is specified, show the usage information for that command."""),

"version": ("Show version information and exit.", ""),

"status": ("Show status of a board.",
        """Usage: lc <board> status

Show the reservation status for a board."""),

"reserve": ("Reserve a board or resource for use.",
    """Usage: lc <board> reserve [-f] <name>

Reserve the named resource.  Currently, only boards may be reserved.
A message and the exit code indicate whether the resource is
already reserved.

If -f is specified, then the reservation is 'forced' and any
current reservation is overridden with the new one.

   ex: lc beablebone reserve"""),

"release": ("Release a reservation on a board or resource.",
    """Usage: lc [board] release

Release the named board or resource.
A message and the exit code indicate if the resource was released.

   ex: lc beaglebone release"""),

}

# here's a helper routine to print a variable with it's name and value
def dvar(name):
    print("DEBUG: python var %s=%s" % (name, caller.f_locals[name]))

# define the debug/verbosity-level based output routines
# Note that not every print should use these.
#  if a print statement is fundamentally part of the execution
#  of a command (e.g. the actual data from a command), it should
#  continue to use 'print()', rather than these level-based
#  functions.
def dprint(msg):
    global debug
    if debug:
        print("DEBUG: " + msg)

def vprint(msg):
    global verbose
    if verbose:
        print(msg)


class config_class:
    def __init__(self, config_filepath):
        # read configuration data from a file
        try:
            data = open(config_filepath, "r").read()
        except:
            error_out("ERROR: could not read LabControl configuration data from %s" % config_filepath)

        conf_map = self.parse_conf(data)

        # set values from conf_map
        self.host = conf_map.get("host", "localhost")
        self.user = conf_map.get("user", "lc_user")
        self.auth_token = conf_map.get("token", "abcd01234")
        self.server = conf_map.get("server", "localhost:8000")
        self.default_board = conf_map.get("default_board", "")
        self.API_URL_BASE = "http://%s/lcserver.py/" % self.server
        self.config_filepath = config_filepath

    # fuego configuration file syntax:
    # ------------------------
    # empty lines and lines starting with # are ignored
    # single-line attribute:
    # name=value
    # multi-line attribute:
    # name="""value line 1
    # line 2, etc."""

    # returns a map with key/value pairs for each item.
    def parse_conf(self, data):
        attr_map = {}
        lines = data.split('\n')
        line_no = 0
        in_block = 0
        block = ""
        for line in lines:
            line_no += 1
            if in_block:
                # try to find end of block
                if line.rstrip().endswith('"""'):
                    # remove quotes and end block
                    line = line.rstrip()
                    block += line[:-3]
                    attr_map[attr] = block
                    in_block = 0
                    continue
                else:
                    block += line + '\n'
                    continue

            # ignore comments
            if line.startswith("#"):
                continue

            # ignore empty lines
            line = line.strip()
            if not line:
                continue

            # if we're outside a block, look for name=value lines

            # line should have an equals in it
            # (either single line name=value, or multi-line block start)
            if line.find("=") == -1:
                print("ERROR: Missing '=' at line %d in Fuego config file" % line_no)
                continue

            (attr, value) = line.split('=', 1)
            attr = attr.strip()
            value = value.strip()
            if value.find('"""') == -1:
                # if a single-line, just record the attribute
                if value.startswith('"') and value.endswith('"'):
                    # remove single-quotes
                    # (if value needs quotes, enclose in triple-quotes)
                    value = value[1:-1]
                attr_map[attr] = value
            else:
                # if the start of a multi-line block...
                vstart = value.find('"""')
                block = value[vstart+3:] + '\n'
                in_block = 1
                # sanity check for block terminator on same line
                # if this line has triple-quotes, then the
                # block begins and ends on the same line.
                if block.endswith('"""\n'):
                    block = block[:block.index('"""')]
                    attr_map[attr] = block
                    in_block = 0
                # NOTE: there's a weird corner case with a line like:
                # 'my_attr=""" foo bar """ more stuff '
                # this will not terminate the block

        # check for dangling material
        if in_block:
            print('ERROR: Syntax error in configuration file.')
            print('Missing """ at end of multiline value for item "%s", at end of file' % attr)
            attr_map[attr] = block

        return attr_map

    def save(self):
        # note: This overwrites any comments in the file
        # It would be nicer to scan the file and replace lines as they appear
        # and to save other config items found in config_class
        # (excepting generated ones)
        fd = open(self.config_filepath, "w+")
        fd.write("server=%s\n" % self.server)
        fd.write("host=%s\n" % self.host)
        fd.write("user=%s\n" % self.user)
        fd.write("token=%s\n" % self.auth_token)
        if self.default_board:
            fd.write("default_board=%s\n" % self.default_board)
        fd.close()


def usage(rcode, options=[]):
    command = ""
    if len(options):
        command = options[0]

    # check if command is legal
    if command and command not in command_help.keys():
        print "Unknown command: %s" % command
        command = ""
        # drop through to showing list of commands

    if not command:
        # show list of commands
        print """Usage: lc [global_options] command [options]

Here are the available global options:
 -h, --help     Show this usage help
 -v             Be verbose
 -q             Be quiet
 -c <conf_file> Use specified configuration file
 --debug        Show debugging information

command is one of:
"""
        command_list = command_help.keys()
        command_list.sort()
        for command in command_list:
            print "  %13s %s" % (command, command_help[command][0])
    else:
        # print help for individual command
        print "lc %s: %s" % (command, command_help[command][0])
        if command_help[command][1]:
            print
            print command_help[command][1]

    sys.exit(rcode)

def print_error(message):
    sys.stderr.write("Error: "+message+"\n")
    sys.stderr.flush()


def error_out(message, rcode=1):
    print_error(message)
    sys.exit(rcode)


def dequote(str):
    if str.startswith('"') and str.endswith('"'):
        return str[1:-1]
    else:
        return str

# shows a list title, if not quiet, and
# returns an indent to use for the list
def show_list_title(title):
    global quiet

    if not quiet:
        print title
        indent = "   "
    else:
        # machine-readable (-q) output omits the title and indent
        indent = ""
    return indent


# returns a list of objects
# if an error occurs, then the routine errors out with a message
def get_objects_via_api(conf, obj_type, options):
    url = conf.API_URL_BASE+"api/v0.2/" + obj_type

    headers = { "Authorization": "token " + conf.auth_token }

    resp = requests.get(url, headers=headers)
    if resp.status_code != 200:
        error_out("Cannot read %s from server" % obj_type)

    resp_data = resp.json()
    if type(resp_data) != type([]):
        # print error
        try:
            reason = resp_data["message"]
        except:
            reason = "for unknown reasons"
        error_out("Could not get %s from server: %s" % (obj_type, reason))

    return resp_data


def list_objects_via_api(conf, obj_type, options):
    global quiet

    server_obj_type = obj_type
    if obj_type == "boards":
        server_obj_type = "devices"

    obj_list = get_objects_via_api(conf, server_obj_type, options)

    indent = show_list_title("%s on the LabControl server:" % obj_type.title())
    if obj_list:
        for obj in obj_list:
            print indent + obj
    else:
        if options:
            extra_msg = " that match the specified criteria"
        else:
            extra_msg = ""
        if not quiet:
            print("No %s found%s." % (obj_type, extra_msg))

    sys.exit(0)

def do_config(conf, options):
    """
        Show all config options, or a single config option
    """
    try:
        name = options[0]
    except:
        # list configuration options
        conf_item_list = []
        for item in conf.__dict__.keys():
            # filter out computed items
            if item not in ["API_URL_BASE"]:
                conf_item_list.append(item)
        conf_item_list.sort()
        for item in conf_item_list:
            print("%s=%s" % (item, getattr(conf, item)))
        sys.exit(1)

    print getattr(conf, name, "")

def do_login(conf, options):
    """
        Login to a server, which consists of providing a user and password, and
        getting the authentication token (used for future requests)
    """
    # for now, support only interactive operations

    print("Currently configured for user '%s' and server '%s'" % (conf.user, conf.server))

    new_server = get_input("Enter Server: [%s] " % conf.server)
    if not new_server:
        new_server = conf.server
    new_user = get_input("Enter User Name: [%s] " % conf.user)
    if not new_user:
        new_user = conf.user

    import getpass
    password = getpass.getpass("Enter Password: ")

    # get token from server
    url = conf.API_URL_BASE+"api/v0.2/token"
    headers = { "Content-Type": "application/json" }
    jdata = '{ "username": "%s", "password": "%s" }' % (new_user, password)

    resp = requests.post(url, headers=headers, data=jdata)

    if resp.status_code != 200:
        error_out("Cannot login to server '%s'" % new_server )

    resp_data = resp.json()

    try:
        result = resp_data["result"]
    except:
        error_out("Malformed response from server. Missing 'result'. resp=%s" % resp_data)

    if result != RSLT_OK:
        # print error
        try:
            reason = resp_data["message"]
        except:
            reason = "for unknown reason (response missing reason)"
        error_out("Login failure: " + reason)

    try:
        token = resp_data["data"]["token"]
    except:
        error_out("Malformed response from server. Missing 'token'. resp=%s" % resp_data)

    # save token to configuration file
    conf.server = new_server
    conf.user = new_user
    conf.auth_token = token
    conf.save()

    print("Succesfully logged in as user '%s'" % conf.user)

    sys.exit(0)

def do_list(conf, options):
    """
    Show a list of objects on the server.  object type is a required
    first argument.
    """
    try:
        obj_type = options[0]
        del options[0]
    except:
        error_out("No object type specified for list operation" + \
                "Please specify either 'boards', 'devices', or 'resources'.")

    if obj_type not in ["boards", "devices", "resources"]:
        error_out(("Invalid object type '%s'\n" % obj_type) + \
                "Please specify one of: 'boards', 'devices', or 'resources'.")

    list_objects_via_api(conf, obj_type, options)


def do_list_mydevices(conf, options):
    """
    Show devices (boards) assigned to me (that is, with a reservation by me
    on the server).
    """
    url = conf.API_URL_BASE+"api/v0.2/devices/mine"

    headers = { "Authorization": "token " + conf.auth_token }

    resp = requests.get(url, headers=headers)
    if resp.status_code != 200:
        error_out("Cannot read %s from server" % obj_type)

    resp_data = resp.json()
    if type(resp_data) != type([]):
        # print error
        try:
            reason = resp_data["message"]
        except:
            reason = "for unknown reasons"
        error_out("Could not get %s from server: %s" % (obj_type, reason))

    indent = show_list_title("Boards reserved for me on the LabControl server:")
    if resp_data:
        for board in resp_data:
            print indent + board
    else:
        if not quiet:
            print("No boards found assigned to me.")

    sys.exit(0)

def do_power(conf, options):
    # board is a required first argument
    try:
        board = options[0]
        del options[0]
    except:
        error_out("No board specified for power operation\n" + \
                "Please specify a board from the list available with 'lc list boards'.")

    # figure out what power operation we're performing
    # should be one of 'status', 'on', 'off', 'reboot'
    try:
        operation = options[0].lower()
        del options[0]
    except:
        error_out("No power operation specified.\n" + \
                "Please specify one of 'status', 'on', 'off', or 'reboot'.")

    if operation not in ["status", "on", "off", "reboot"]:
        error_out("Invalid power operation specified.\n" + \
                "Please specify one of 'status', 'on', 'off', or 'reboot'.")

    url = conf.API_URL_BASE+"api/v0.2/devices/%s/power/%s" % (board, operation)

    headers = { "Authorization": "token " + conf.auth_token }

    resp = requests.get(url, headers=headers)
    if resp.status_code != 200:
        error_out("Cannot perform power %s operation on server" % operation )

    resp_data = resp.json()

    try:
        result = resp_data["result"]
    except:
        error_out("Malformed response from server. Missing 'result'. resp=%s" % resp_data)

    if result != RSLT_OK:
        # print error
        try:
            reason = resp_data["message"]
        except:
            reason = "for unknown reasons"
        error_out("Could not do operation 'power %s'. %s" % (operation, reason))

    # operation was performed, result was "success"

    # report status depending on operation
    if operation in ["on", "off"]:
        print "Device %s is powered %s" % (board, operation.upper())
        return
    if operation == "reboot":
        print "Device %s was rebooted." % board
        return
    if operation == "status":
        power_status = resp_data["data"]
        print "Device %s is powered %s" % (board, power_status)
        return

    # this seems unlikely, given the checks above
    # but be thorough in error handling
    error_out("Invalid operation '%s' for power command" % operation)

def do_run(conf, options):
    # board is a required first argument
    try:
        board = options[0]
        del options[0]
    except:
        error_out("No board specified for power operation\n" + \
                "Please specify a board from the list available with 'lc list boards'.")

    if not options:
        error_out("No power operation specified.\n" + \
                "Please specify one of 'status', 'on', 'off', or 'reboot'.")

    # FIXTHIS - not sure about just joining the args with a space
    # what happens to single arguments with a space?
    run_cmd = " ".join(options)

    url = conf.API_URL_BASE+"api/v0.2/devices/%s/run/" % board

    jdata = '{ "command": "%s", "device_ip": "*", "username":"*" }' % run_cmd

    headers = { "Authorization": "token " + conf.auth_token,
            "Content-type": "application/json"}

    resp = requests.post(url, headers=headers, data=jdata)
    if resp.status_code != 200:
        error_out("Cannot perform 'run' operation on server")

    #print("resp.content='%s'" % resp.content)

    resp_data = resp.json()
    #print("resp_data='%s'" % resp_data)

    try:
        result = resp_data["result"]
    except:
        error_out("Malformed response from server. Missing 'result'. resp=%s" % resp_data)

    if result != RSLT_OK:
        # print error
        try:
            reason = resp_data["message"]
        except:
            reason = "for unknown reasons"
        error_out("Could not do operation 'power %s'. %s" % (operation, reason))

    # command was performed, result was "success"
    return_code = resp_data["data"]["return_code"]
    output = resp_data["data"]["data"]
    for line in output:
        sys.stdout.write(line)
        #sys.stdout.write(line + "\n")

    sys.exit(return_code)

def do_reserve(conf, options, cmd='reserve'):
    # board is a required first argument
    try:
        board = options[0]
        del options[0]
    except:
        error_out("No board specified for %s operation\n" % cmd + \
                "Please specify a board from 'lc list boards'.")

    url = conf.API_URL_BASE+"api/v0.2/devices/%s/assign" % board

    headers = { "Authorization": "token " + conf.auth_token }

    resp = requests.get(url, headers=headers)
    if resp.status_code != 200:
        error_out("Cannot perform %s operation on server" % cmd )

    resp_data = resp.json()

    try:
        result = resp_data["result"]
    except:
        error_out("Malformed response from server. Missing 'result'. resp=%s" % resp_data)

    if result != RSLT_OK:
        # print error
        try:
            reason = resp_data["message"]
        except:
            reason = "for unknown reasons"
        error_out("%s" % reason)

    # operation was performed, result was "success"
    print("Device is assigned to user %s" % conf.user)
    return

def do_release(conf, options):
    # board is a required first argument
    try:
        board = options[0]
        del options[0]
    except:
        error_out("No board specified for release operation\n" + \
            "Please specify a board from 'lc list boards'.")

    url = conf.API_URL_BASE+"api/v0.2/devices/%s/release" % board

    if len(options) and options[0]=="force":
        url += "/force"

    headers = { "Authorization": "token " + conf.auth_token }

    resp = requests.get(url, headers=headers)
    if resp.status_code != 200:
        error_out("Cannot perform release operation on server")

    resp_data = resp.json()

    try:
        result = resp_data["result"]
    except:
        error_out("Malformed response from server. Missing 'result'. resp=%s" % resp_data)

    if result != RSLT_OK:
        # print error
        try:
            reason = resp_data["message"]
        except:
            reason = "Could not do 'assign' operation, for unknown reasons"
        error_out("%s" % reason)

    # operation was performed, result was "success"
    print('Device "%s" is released and available to use.' % board)
    return


# show the status of a board
def do_status(conf, options):
    board = options[0]
    del(options[0])

    url = conf.API_URL_BASE+"api/v0.2/devices/" + board

    headers = { "Authorization": "token " + conf.auth_token }

    resp = requests.get(url, headers=headers)
    if resp.status_code != 200:
        error_out("Cannot read %s from server" % obj_type)

    try:
        resp_data = resp.json()
    except:
        error_out("Could not parse data from server")

    try:
        result = resp_data["result"]
    except:
        error_out("Can not determine result from server")

    if result != RSLT_OK:
        try:
            reason = resp_data["message"]
        except:
            reason = "Unknown failure from server"
        error_out(reason)

    print "Status for board: %s" % board

    # show who is currently using board
    assigned_to = resp_data.get("AssignedTo", "nobody")
    if assigned_to != "nobody":
        print 'Board "%s" is assigned to user "%s".' % (board, assigned_to)
    else:
        print 'Board "%s" is not reserved.' % (board)

    # FIXTHIS - do_status could report other board status data (power, etc.):
    #   board power-on status
    #   whether board is running linux (pingable?)
    #   future reservations for board

def do_get_resource(conf, options):
    # board is a required first argument
    try:
        board = options[0]
        del options[0]
    except:
        error_out("No board specified for get_resource operation\n" \
                "Please specify a board from 'lc list boards'.")

    try:
        res_type = options[0]
        del options[0]
    except:
        error_out("No resource type specified for get_resource operation\n" \
                "Please specify a valid resource type.")

    api_url = "api/v0.2/devices/%s/get_resource/%s" % (board, res_type)
    url = conf.API_URL_BASE + api_url

    if options:
        # make feature string suitable to append to url
        feature_str = urllib.quote(options[0]).replace("/", "%2F")
        url += "/" +  feature_str.replace("/", "%2F")

    headers = { "Authorization": "token " + conf.auth_token }

    resp = requests.get(url, headers=headers)
    if resp.status_code != 200:
        error_out("Cannot perform 'get_resource' operation on server")

    resp_data = resp.json()

    try:
        result = resp_data["result"]
    except:
        error_out("Malformed response from server. Missing 'result'. resp=%s" % resp_data)

    if result != RSLT_OK:
        # print error
        try:
            reason = resp_data["message"]
            if reason.startswith("Error: "):
                    reason = reason[6:]
        except:
            reason = "for unknown reasons"
        error_out("%s" % reason)

    try:
        data = resp_data["data"]
    except:
        error_out("Malformed response from server. Missing 'data'. resp=%s" % resp_data)

    # operation was performed, result was "success", print the resource name
    print(data)
    return

def do_power_measurement(conf, options, cmd):
    # resource is a required first argument
    try:
        resource = options[0]
        del options[0]
    except:
        error_out("No resource specified for power operation\n" + \
                "Please specify a resource associated with this board\n" + \
                "try 'lc list resources'.")

    # figure out what power operation we're performing
    # should be one of 'start', 'stop', 'get_data', 'delete'
    try:
        operation = options[0].lower()
        del options[0]
    except:
        error_out("No power_measurement operation specified.\n" + \
                "Please specify one of 'start', 'stop', 'get_data', or 'delete'.")

    if operation not in ["start", "stop", "get_data", "delete"]:
        error_out("Invalid power operation specified.\n" + \
                "Please specify one of 'start', 'stop', 'get_data', or 'delete'.")

    url_op  = { "start": "start_capture", "stop": "stop_capture", "get_data": "get_data", "delete": "delete" }[operation]

    url = conf.API_URL_BASE+"api/v0.2/resources/%s/power_measurement/%s" % (resource, url_op)
    headers = { "Authorization": "token " + conf.auth_token }

    if operation in ["stop", "get_data", "delete"]:
        try:
            token = options[0]
            del options[0]
        except:
            error_out("No token provided for '%s' operation.\n" % operation)
        url += "/%s" % token
        # FIXTHIS - power_measurement operation should be a 'post' according to the spec
        resp = requests.get(url, headers=headers)
    else:
        resp = requests.get(url, headers=headers)

    if resp.status_code != 200:
        error_out("Cannot perform power_measurement %s operation on server" % operation )

    resp_data = resp.json()

    try:
        result = resp_data["result"]
    except:
        error_out("Malformed response from server. Missing 'result'. resp=%s" % resp_data)

    if result != RSLT_OK:
        # print error
        try:
            reason = resp_data["message"]
        except:
            reason = "for unknown reasons"
        error_out("Could not do operation 'power_measurement %s'. From server:\n %s" % (operation, reason))

    # operation was performed, result was "success"

    # report status depending on operation
    if operation == "start":
        # output token to user
        try:
            token = resp_data["data"]
        except:
            error_out("Missing data capture token from server.")

        print(token)
        return

    if operation == "stop":
        print "Capture was stopped."
        return
    if operation == "delete":
        print "Capture was deleted from server."
        return
    if operation == "get_data":
        # write json capture data to stdout
        try:
            data = resp_data["data"]
        except:
            error_out("Missing captureed from server.")

        print(data)
        return

    # this seems unlikely, given the checks above
    # but be thorough in error handling
    error_out("Invalid operation '%s' for power_measurement command" % operation)

def do_set_config(conf, options, cmd):
    # resource is a required first argument
    try:
        resource = options[0]
        del options[0]
    except:
        error_out("No resource specified for set-config operation\n" + \
                "Please specify a resource associated with this board\n" + \
                "try 'lc list resources'.")

    try:
        res_type = options[0]
        del options[0]
    except:
        error_out("No resource type specified for set-config operation\n" + \
                "Please specify a valid resource type (only 'serial' is supported)\n")

    operation = "set-config"

    url = conf.API_URL_BASE+"api/v0.2/resources/%s/%s/set-config" % (resource, res_type)
    headers = { "Authorization": "token " + conf.auth_token }

    # read standard input for json data
    config_data = sys.stdin.read()

    #print("config data=%s" % config_data)

    resp = requests.post(url, headers=headers, data=config_data)

    if resp.status_code != 200:
        error_out("Cannot perform %s %s operation on server" % (res_type, operation))

    try:
        resp_data = resp.json()
    except ValueError:
        error_out("Could not parse response data as json. data=" + resp.content)

    try:
        result = resp_data["result"]
    except:
        error_out("Malformed response from server. Missing 'result'. resp=" + resp_data)

    if result != RSLT_OK:
        # print error
        try:
            reason = resp_data["message"]
        except:
            reason = "for unknown reasons"
        reason = "%s" % reason
        error_out("Could not do operation '%s %s'. From server:\n %s" % (res_type, operation, reason))

    # operation was performed, result was "success"
    print("Set_config operation was successful")

# this is almost verbatim from do_power_measurement - should try
# to find a way to coalesce these.
def do_serial(conf, options, cmd):
    # resource is a required first argument
    try:
        resource = options[0]
        del options[0]
    except:
        error_out("No resource specified for serial operation\n" + \
                "Please specify a resource associated with this board\n" + \
                "try 'lc list resources'.")

    # figure out what power operation we're performing
    # should be one of 'start', 'stop', 'get_data', 'delete'
    try:
        operation = options[0].lower()
        del options[0]
    except:
        error_out("No serial operation specified.\n" + \
                "Please specify one of 'start', 'stop', 'get_data', or 'delete'.")

    if operation not in ["start", "stop", "get_data", "delete"]:
        error_out("Invalid serial specified.\n" + \
                "Please specify one of 'start', 'stop', 'get_data', or 'delete'.")

    url_op  = { "start": "start_capture", "stop": "stop_capture", "get_data": "get_data", "delete": "delete" }[operation]

    url = conf.API_URL_BASE+"api/v0.2/resources/%s/serial/%s" % (resource, url_op)
    headers = { "Authorization": "token " + conf.auth_token }

    if operation in ["stop", "get_data", "delete"]:
        try:
            token = options[0]
            del options[0]
        except:
            error_out("No token provided for '%s' operation.\n" % operation)
        url += "/%s" % token
        # FIXTHIS - serial operation should be a 'post' according to the spec
        resp = requests.get(url, headers=headers)
    else:
        resp = requests.get(url, headers=headers)

    if resp.status_code != 200:
        error_out("Cannot perform serial %s operation on server" % operation )

    resp_data = resp.json()

    try:
        result = resp_data["result"]
    except:
        error_out("Malformed response from server. Missing 'result'. resp=%s" % resp_data)

    if result != RSLT_OK:
        # print error
        try:
            reason = resp_data["message"]
        except:
            reason = "for unknown reasons"
        error_out("Could not do operation 'serial %s'. From server:\n %s" % (operation, reason))

    # operation was performed, result was "success"

    # report status depending on operation
    if operation == "start":
        # output token to user
        try:
            token = resp_data["data"]
        except:
            error_out("Missing data capture token from server.")

        print(token)
        return

    if operation == "stop":
        print "Capture was stopped."
        return
    if operation == "delete":
        print "Capture was deleted from server."
        return
    if operation == "get_data":
        # write json capture data to stdout
        try:
            data = resp_data["data"]
        except:
            error_out("Missing captureed from server.")

        print(data)
        return

    # this seems unlikely, given the checks above
    # but be thorough in error handling
    error_out("Invalid operation '%s' for serial command" % operation)


def main():
    global verbose
    global quiet
    global debug
    global server

    # find the configuration file

    # check for config in user's home directory
    # if present, this supercedes the system-wide config
    home = os.environ.get("HOME", "")
    config_filepath = home + os.sep + config_filename

    if not home or not os.path.exists(config_filepath):
        config_filepath = system_config_filepath

    if len(sys.argv) < 2:
        error_out('Missing command\nUse "lc help" to get usage help.', 1)

    # parse arguments
    command_list = command_help.keys()
    command_list.extend(["--help", "-h", "pm"])
    options = []

    board = ""
    command = ""
    quiet = False
    verbose = False
    # find command, board, and any arguments
    arglist = sys.argv[1:]
    for arg in arglist:
        if arg == "-q":
            quiet = True
            continue
        if arg == "-v":
            verbose = True
            ll_verbose = True
            continue
        if arg == "--debug":
            debug = True
            ll_debug = True
            continue
        if arg == "-c":
            config_filepath = arglist[arglist.index("-c")+1]
            # this is dicey - it relies on the for loop to continue
            # properly if arglist is manipulated while the 'for' is running
            arglist.remove(config_filepath)
            continue
        if arg in command_list:
            # support "lc <command> help"
            if (arg == "help" or arg == "-h" or arg == "--help") and command:
                options.append(command)
                command = arg
                continue

            # support "lc help <command>" and "lc run reboot"
            # -- where arg has same name as a legal lc command
            if command:
                # this is an argument to the command
                # which was already found
                # note: check for 'help' arg (above) must come first
                options.append(arg)
            else:
                # normal "lc <command>" case

                command = arg
            continue

        options.append(arg)

    # if no command recognized, return
    if not command:
        error_out('Missing or unregonized command\nUse "lc help" to get usage help.', 1)

    if command == "help" or command == "--help" or command == "-h":
        usage(0, options)

    if command == "version":
        print "lc: version %d.%d.%d%s" % VERSION
        sys.exit(0)

    # read config
    conf = config_class(config_filepath)

    if command == "config":
        do_config(conf, options)
        sys.exit(0)
        try:
            name = options[0]
        except:
            # list configuration options
            conf_item_list = []
            for item in conf.__dict__.keys():
                # filter out computed items
                if item not in ["API_URL_BASE"]:
                    conf_item_list.append(item)
            conf_item_list.sort()
            for item in conf_item_list:
                print("%s=%s" % (item, getattr(conf, item)))
            sys.exit(1)

        print getattr(conf, name, "")

    if command == "login":
        do_login(conf, options)

    if command == "list":
        do_list(conf, options)

    if command == "power":
        do_power(conf, options)
        sys.exit(0)

    if command in ["allocate", "reserve"]:
        do_reserve(conf, options, command)
        sys.exit(0)

    if command == "release":
        do_release(conf, options)
        sys.exit(0)

    if command == "mydevices":
        do_list_mydevices(conf, options)
        sys.exit(0)

    if command == "status":
        do_status(conf, options)
        sys.exit(0)

    if command == "get-resource":
        do_get_resource(conf, options)
        sys.exit(0)

    if command in ["power-measurement", "pm"]:
        do_power_measurement(conf, options, command)
        sys.exit(0)

    if command == "serial":
        do_serial(conf, options, command)
        sys.exit(0)

    if command == "set-config":
        do_set_config(conf, options, command)
        sys.exit(0)

    if command == "run":
        do_run(conf, options)
        # no return here

    error_out("Unknown command %s" % command)


if __name__ == "__main__":
    try:
        main()
    except requests.ConnectionError:
        error_out("Could not connect to server.  Check that server is running\n" \
                "and that you have the right server in your configuration file.")
        sys.exit(1)
